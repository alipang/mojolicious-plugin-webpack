package Mojo::Alien::webpack;
use Mojo::Base -base;

use Carp qw(croak);
use File::chdir;
use Mojo::Alien::npm;
use Mojo::File qw(path tempfile);
use Mojo::Loader qw(data_section);
use POSIX ':sys_wait_h';
use Time::HiRes qw(sleep);

use constant DEBUG => $ENV{MOJO_WEBPACK_DEBUG} && 1;

# TODO
our $VERSION = $Mojolicious::Plugin::Webpack::VERSION || '0.01';

has command => sub {
  my $self = shift;
  return [$ENV{MOJO_WEBPACK_BINARY}] if $ENV{MOJO_WEBPACK_BINARY};
  my $bin = $self->config->to_abs->dirname->child(qw(node_modules .bin webpack));
  warn "[Webpack] @{[-e $bin ? 'Found' : 'Not installed']} $bin\n" if DEBUG;
  return -e $bin ? [$bin->to_string] : ['webpack'];
};

has config => sub { path->to_abs->child('webpack.config.js') };
has mode   => sub { $ENV{NODE_ENV} || 'development' };

has npm => sub {
  my $self = shift;
  Mojo::Alien::npm->new(config => $self->config->dirname->child('package.json'), mode => $self->mode);
};

has out_dir => sub { shift->config->dirname->child('dist') };

sub build {
  my $self = shift;
  croak "Can't call build() after watch()" if $self->pid;

  ($!, $?) = (0, 0);
  $self->_run($self->_cmd_build);
  croak "$self->{basename} $! (exit=$?)"   if $!;
  croak "$self->{basename} failed exit=$?" if !$! and $?;

  return $self;
}

sub init {
  my $self = shift;
  $self->npm->init;
  $self->npm->install($_, {type => 'dev'}) for grep { !$self->npm->dependency_info($_) } qw(webpack webpack-cli);
  $self->_render_file('webpack.config.js');
  return $self;
}

sub pid {
  my $self = shift;
  return 0 unless $self->{pid};
  my $r = waitpid $self->{pid}, WNOHANG;    # -1 == no such process, >0 if terminated
  return $r == -1 && delete $self->{pid} ? 0 : $r ? 0 : $self->{pid};
}

sub stop {
  my ($self, $tries) = @_;

  $tries ||= 100;
  while (--$tries) {
    return $self unless my $pid = $self->pid;
    local $!;
    kill 15, $pid;
    waitpid $pid, 0;
    sleep $ENV{MOJO_WEBPACK_STOP_INTERVAL} || 0.1;
  }

  $self->{basename} ||= path($self->command->[0])->basename;
  croak "Couldn't stop $self->{basename} with pid @{[$self->pid]}";
}

sub watch {
  my $self = shift;
  return $self if $self->pid;

  my $home = $self->config->dirname->to_string;
  croak "Can't chdir $home: No such file or directory" unless -d $home;

  my @cmd = ($self->_cmd_build, '--watch');
  croak "Can't fork: $!" unless defined(my $pid = fork);

  # Parent
  return $self if $self->{pid} = $pid;

  # Child
  chdir $home or die "[Webpack] Can't chdir to $home: $!";
  $ENV{NODE_ENV}           = $self->mode;
  $ENV{WEBPACK_ASSETS_DIR} = $self->assets_dir->to_string;
  $ENV{WEBPACK_OUT_DIR}    = $self->out_dir->to_string;
  warn "[Webpack:$$] cd $home && @_\n" if DEBUG;
  { exec @cmd }
  die "[Webpack] Can't run @cmd: $!";
}

sub _cmd_build {
  my $self = shift;
  $self->init unless $self->{init}++;

  my @cmd = @{$self->command};
  croak "Can't run $cmd[0]" unless -x $cmd[0];

  $self->{basename} ||= path($cmd[0])->basename;
  $self->{stats}    ||= tempfile;
  push @cmd, '--config' => $self->config->to_string;
  push @cmd, sprintf '--json=%s', $self->{stats}->to_string;
  push @cmd, qw(--progress --profile --verbose) if $ENV{MOJO_WEBPACK_VERBOSE};
  return @cmd;
}

sub _render_file {
  my ($self, $name) = @_;

  my $file = $self->config->dirname->child(split '/', $name);
  if (-e $file) {
    my $version = $file->slurp =~ m!// Autogenerated.*(\d+\.\d+)! ? $1 : -1;
    warn "[Webpack] File $name has version $version in $file\n" if DEBUG;
    return $self if !$ENV{TEST_MOJO_WEBPACK} and ($version == -1 or $version == $VERSION);
  }

  warn "[Webpack] Render $name to $file\n" if DEBUG;
  state $template = do { require Mojo::Template; Mojo::Template->new({vars => 1})->name("$name from DATA section") };
  my $output = $template->render(data_section(ref $self, $name), {self => $self, version => $VERSION});
  die $output if ref $output;
  $file->spurt($output);
  return $self;
}

sub _run {
  my ($self, @cmd) = @_;
  local $CWD                     = $self->config->dirname->to_string;
  local $ENV{NODE_ENV}           = $self->mode;
  local $ENV{WEBPACK_ASSETS_DIR} = $self->assets_dir->to_string;
  local $ENV{WEBPACK_OUT_DIR}    = $self->out_dir->to_string;
  warn "[Webpack] cd $CWD && @cmd\n" if DEBUG;
  open my $WEBPACK, '-|', @cmd or die "Can't run @cmd: $!";
  return $WEBPACK if defined wantarray;
  map { DEBUG && print } <$WEBPACK>;
}

sub DESTROY { shift->stop }

1;

=encoding utf8

=head1 NAME

Mojo::Alien::webpack - Runs the external nodejs program webpack

=head1 SYNOPSIS

  use Mojo::Alien::webpack;
  my $webpack = Mojo::Alien::webpack->new;

  # Run once
  $webpack->build;

  # Build when webpack see files change
  $webpack->watch;

=head1 DESCRIPTION

L<Mojo::Alien::webpack> is a class for runnig the external nodejs program
L<webpack|https://webpack.js.org/>.

=head1 ATTRIBUTES

=head2 command

  $array_ref = $webpack->command;
  $webpack = $webpack->command(['webpack']);

The path to the webpack executable and any custom arguments that is required
for L</build> and L</watch>. This variable tries to find webpack in
"node_modules/" before falling back to just "webpack".

The C<MOJO_WEBPACK_BINARY> environment variable can be set to change the
default.

=head2 config

  $path = $webpack->config;
  $webpack = $webpack->config(path->to_abs->child('webpack.config.js'));

Holds an I</absolute> path to
L<webpack.config.js|https://webpack.js.org/concepts/configuration/>.

=head2 mode

  $str = $webpack->mode;
  $webpack = $webpack->mode('development');

Should be either "development" or "production". Will be used as "NODE_ENV"
environment variable when calling L</build> or L</watch>.

=head2 npm

  $npm = $webpack->npm;

A L<Mojo::Alien::npm> object used by L</init>.

=head2 out_dir

  $path = $webpack->out_dir;
  $webpack = $webpack->out_dir(path('dist')->to_abs);

Location to write output assets to.

=head1 METHODS

=head2 build

  $webpack->build;

Will build the assets or croaks on errors.

=head2 init

  $webpack = $webpack->init;

Will install "webpack" and "webpack-cli" and create a default L</config>. Does
nothing if this is already done.

This method is automatically called by L</build> and L</watch>.

=head2 pid

  $int = $webpack->pid;

Returns the PID of the webpack process started by L</start>.

=head2 stop

  $webpack->stop;

Will stop the process started by L</watch>. Does nothing if L</watch> has not
been called.

=head2 watch

  $webpack->watch;

Forks a new process that runs "webpack watch". This means that any changes will
generate new assets. This is much more efficient than calling L</build> over
and over again. Automatically calls L</init>.

=head1 SEE ALSO

L<Mojolicious::Plugin::Webpack>.

=cut

__DATA__
@@ webpack.config.js
// Autogenerated by Mojo::Alien::webpack <%= $version %>
const fs = require('fs');
const package = require('./package.json');
const path = require('path');

const isDev = process.env.NODE_ENV !== 'production';

const config = {
  entry: {},
  mode: isDev ? 'development' : 'production',
  module: {rules: []},
  optimization: {minimizer: []},
  output: {},
  plugins: [],
};

config.output.filename = isDev ? '[name].development.js' : '[name].[chunkhash].js';
config.output.path = process.env.WEBPACK_OUT_DIR || path.resolve(__dirname, 'dist');
config.output.publicPath = '';

const entry = path.resolve('assets', 'index.js');
if (fs.existsSync(entry)) config.entry[package.name.replace(/\W+/g, '-')] = entry;

const custom = path.resolve(__dirname, 'assets', 'webpack.custom.js');
if (fs.existsSync(custom)) require(custom)(config);

module.exports = config;
